---
layout: post
title:  Вейвлет-сжатие «на пальцах»
---

10.02.2013

<h4>Введение</h4>

<img src="https://habrastorage.org/storage2/fc0/c54/b17/fc0c54b17780bed402547df3aa15b416.png" align="left"/>

Вейвлеты сейчас на слуху. Даже неискушённые в математике люди
наверняка слышали, что с их помощью удаётся сжимать изображения и
видео сохраняя приемлемое качество. Но что же такое вейвлет? Википедия
отвечает на этот вопрос целым ворохом формул за которыми не так-то
легко увидеть суть.

Попробуем на простых примерах разобраться, откуда же вообще берутся
вейвлеты и как их можно использовать при сжатии. Предполагается, что
читатель знаком с основами линейной алгебры, не боится слов вектор и
матрица, а также умеет их перемножать.

<habracut />

<h4>Сжатие изображений</h4>

Упрощённо, изображение представляют собой таблицу, в ячейках которой
хранятся цвета каждого пикселя. Если мы работаем с чёрно-белым (или,
точнее, серым) изображением, то вместо цвета в ячейки помещают
значения яркости из отрезка [0, 1]. При этом 0 соответствует чёрному
цвету, 1 — белому. Но с дробями работать неудобно, поэтому часто
значения яркости берут целыми из диапазона от 0 до 255. Тогда каждое
значение будет занимать ровно 1 байт.

Даже небольшие изображения требуют много памяти для хранения. Так,
если мы кодируем яркость каждого пикселя одним байтом, то изображение
одного кадра формата FullHD (1920×1080) займёт почти два
мегабайта. Представьте, сколько памяти потребуется для хранения
полуторачасового фильма!

Поэтому изображения стремятся сжать. То есть закодировать таким
образом, чтобы памяти для хранения требовалось меньше. А во время
просмотра мы декодируем записанные в память данные и получаем исходный
кадр. Но это лишь в идеале.

Существует много алгоритмов сжатия данных. О их количестве можно
судить по форматам, поддерживаемым современными архиваторами: ZIP, 7Z,
RAR, ACE, GZIP, HA, BZ2 и так далее. Неудивительно, что благодаря
активной работе учёных и программистов в настоящее время степень
сжатия данных вплотную подошла к теоретическому пределу.

Плохая новость в том, что для изображения этот теоретический предел не
так уж и велик. Попробуйте сохранить фотографию (особенно с большим
количеством мелких деталей) в формате PNG — размер получившегося файла
может вас расстроить.

Это происходит из-за того, что в изображениях из реального мира
(фотографиях, например) значения яркости редко бывают одинаковыми даже
у соседних пикселей. Всегда есть мельчайшие колебания, которые
неуловимы человеческим глазом, но которые алгоритм сжатия честно
пытается учесть.

Алгоритмы сжатия «любят», когда в данных есть закономерность. Лучше
всего сжимаются длинные последовательности нулей (закономерность тут
очевидна). В самом деле, вместо того, чтобы записывать в память 100
нулей, можно записать просто число 100 (конечно, с пометкой, что это
именно количество нулей). Декодирующая программа «поймёт», что имелись
в виду нули и воспроизведёт их.

Однако если в нашей последовательности в середине вдруг окажется единица, то одним числом 100 ограничится не удастся.

Но зачем кодировать абсолютно все детали? Ведь когда мы смотрим на
фотографию, нам важен общий рисунок, а незначительные колебания
яркости мы и не заметим. А значит, при кодировании мы можем немного
изменить изображение так, чтобы оно хорошо кодировалось. При этом
степень сжатия сразу вырастет. Правда, декодированное изображение
будет незначительно отличаться от исходного, но кто заметит?

<h4>Преобразование Хаара</h4>

Итак, наша цель — преобразовать изображение так, чтобы оно хорошо
сжималось классическими алгоритмами. Подумаем, как нужно изменить его,
чтобы получить длинные цепочки нулей.

У «реальных» изображений, таких как фотографии, есть одна особенность
— яркость соседних пикселей обычно отличается на небольшую величину. В
самом деле, в мире редко можно увидеть резкие, контрастные перепады
яркости. А если они и есть, то занимают лишь малую часть изображения.

Рассмотрим фрагмент первой строки яркостей из известного изображения
«Lenna» (на рисунке). <img
src="https://habrastorage.org/storage2/a99/fcb/5ad/a99fcb5ad9487e4438a453cd47da224c.png"
align="right"/>

<pre>154,  155,  156,  157,  157,  157,  158,  156</pre>

Видно, что соседние числа очень близки. Чтобы получить желаемые нули
или хотя бы что-то близкое к ним, можно закодировать отдельно первое
число, а потом рассматривать лишь отличия каждого числа от
предыдущего.

Получаем:

<pre>154, 1, 1, 1, 0, 0, 1, -2.</pre>

Уже лучше! Такой метод в самом деле используется и называется
дельта-кодированием. Но у него есть серьёзные недостаток — он
нелокальный. То есть нельзя взять кусочек последовательности и узнать,
какие именно яркости в нём закодированы без декодирования всех
значений перед этим кусочком.

Попробуем поступить иначе. Не будем пытаться сразу получить хорошую
последовательность, попробуем улучшить её хотя бы немного.

Для этого разобьём все числа на пары и найдём полусуммы и полуразности
значений в каждой из них.

<pre>(154,  155),  (156,  157),  (157,  157),  (158,  156)</pre>
<pre>(154.5,  0.5),  (156.5,  0.5),  (157,  0.0),  (157,  -1.0)</pre>

Почему именно полусуммы и полуразности? А всё очень просто! Полусумма
— это среднее значение яркости пары пикселей. А полуразность несёт в
себе информацию об отличиях между значениями в паре. Очевидно, зная
полусумму a и полуразность d можно найти и сами значения: первое
значение в паре = a - d, второе значение в паре = a + d.

Это преобразование было предложено в 1909 году Альфредом Хааром и
носит его имя.

<h4>А где же сжатие?</h4>

Полученные числа можно перегруппировать по принципу «мухи отдельно,
котлеты отдельно», разделив полусуммы и полуразности:

<pre>154.5, 156.5, 157, 157; 0.5, 0.5, 0.0, -1.0.</pre>

Числа во второй половине последовательности как правило будут
небольшими (то, что они не целые, пусть пока не смущает). Почему так?

Как мы уже выяснили раньше, в реальных изображениях соседние пиксели
редко отличаются друг от друга значительно. Если значение одного
велико, то и другого велико. В таких случаях говорят, что соседние
пиксели коррелированы.

В самом деле, рассмотрим первые 2000 пар соседних пикселей и каждую
пару представим на графике точкой.

<img src="https://habrastorage.org/storage2/eaf/2cf/012/eaf2cf012aff44aab8936f53b1ef2958.png"/>

Все точки выстраиваются вдоль одной прямой линии. И так практически во
всех реальных изображениях. Верхний левый и нижний правый углы
изображения практически всегда пусты.

А теперь рассмотрим график, точками в котором будут полусуммы и
полуразности.

<img src="https://habrastorage.org/storage2/6bf/b8f/9a1/6bfb8f9a13b1458d813dd3625327b087.png"/>

Видно, что полуразности находятся в гораздо более узком диапазоне
значений. А это значит, что на них можно потратить меньше одного
байта. Какое-никакое, а сжатие.

<h4>Применим математику!</h4>

Попробуем записать математические выражения, описывающие
преобразование Хаара.

Итак, у нас была пара пикселей (вектор) <img src="https://habrastorage.org/storage2/d89/5df/577/d895df5778fa86e8b8a73a1735fbdb0d.png"/>, а мы хотим получить пару <img src="https://habrastorage.org/storage2/6f2/d35/d2e/6f2d35d2ea89e362e6e191384728ae2e.png"/>.

Такое преобразование описывается матрицей <img src="https://habrastorage.org/storage2/8a5/797/898/8a57978986f6d4aa350a75be0e86ee98.png"/>.

В самом деле <img src="https://habrastorage.org/storage2/656/122/c75/656122c75c0da53aff5561aefe2f7ea1.png"/>, что нам и требовалось.

Внимательный читатель наверняка заметил, что рисунки из точек на двух
последних графиках одинаковы. Разница лишь в повороте на угол в 45°.

В математике повороты и растяжения называются аффинными
преобразованиями и описываются как раз при помощи умножения матрицы на
вектор. Что мы и получили выше. То есть, преобразование Хаара — это
просто поворот точек таким образом, чтобы их можно было удобно и
компактно закодировать.

Правда, тут есть один нюанс. При аффинных преобразованиях может
меняться площадь фигуры. Не то, чтобы это было плохо, но как-то
неаккуратненько. Как известно, коэффициент изменения площади равен
определителю матрицы. Посмотрим, каков он для преобразования Хаара.

<img src="https://habrastorage.org/storage2/fd4/b49/0f7/fd4b490f763e3351ba12468b960ded6b.png"/>

Для того, чтобы определитель стал равен единице достаточно умножить
каждый элемент матрицы на <img
src="https://habrastorage.org/storage2/3bb/086/256/3bb086256ba5fcded51e5af92f1f04a2.png"/>. На
угол поворота (а значит, и на «сжимающую способность» преобразования)
это не повлияет.

Получаем в итоге матрицу

<img src="https://habrastorage.org/storage2/273/e45/790/273e45790c5fa83a4d75835da559c08f.png"/>

<h4>А как декодировать?</h4>

Как известно, если у матрицы определитель не равен нулю, то для неё
существует обратная матрица, «отменяющая» её действие. Если мы найдём
обратную матрицу для H, то декодирование будет заключаться просто в
умножении векторов с полусуммами и полуразностями на неё.

<img src="https://habrastorage.org/storage2/7aa/da8/62a/7aada862a1bc891e7df84cc501ee6539.png"/>

Вообще говоря, поиск обратной матрицы — не такая простая задача. Но,
может, удастся как-то эту задачу упростить?

Рассмотрим поближе нашу матрицу. Она состоит из двух вектор-строк: <img src="https://habrastorage.org/storage2/58e/c55/cc0/58ec55cc06471a9b48240f7e18badbff.png"/> и <img src="https://habrastorage.org/storage2/7d9/665/27c/7d966527cd80b42ad8bd4f3d90ea4b0a.png"/>. Назовём их v<sub>1</sub> и v<sub>2</sub>.

Они обладают интересными свойствами.

Во-первых, их длины равны 1, то есть <img
src="https://habrastorage.org/storage2/c2e/863/8a4/c2e8638a486e03ef047b720240257cda.png"/>. Здесь
буква T означает транспонирование. Умножение вектор-строки на
транспонированный вектор-строку — это скалярное произведение.

Во-вторых, они ортогональны, то есть <img
src="https://habrastorage.org/storage2/ef4/945/5a6/ef49455a6c0eea5afcc15dbfd94261aa.png"/>.

Матрица, строки которой обладают указанными свойствами называется
ортогональной. Чрезвычайно важным свойством таких матриц является то,
что обратную матрицу для них можно получить простым транспонированием.

<img src="https://habrastorage.org/storage2/eb9/308/2bd/eb93082bd00b72e12be6510373598424.png"/>

В справедливости этого выражения можно убедиться умножив H обратную
матрицу. На диагонали мы получим скалярные произведения вектор-строк
на самих себя, то есть 1. А вне диагоналей — скалярные произведения
вектор-строк друг на друга, то есть 0. В итоге произведение будет
равно единичной матрице.

Мы любим ортогональные матрицы!

<h4>Увеличиваем число точек</h4>

Всё сказанное хорошо работает для двух точек. Но что делать, если точек больше?

В этом случае тоже можно описать преобразование матрицей, но большей
по размеру. Диагональ этой матрицы будет состоять из матриц H, таким
образом в векторе исходных значений будут выбираться пары, к которым
независимо будет применяться преобразование Хаара.

<img src="https://habrastorage.org/storage2/390/252/689/3902526892ede15e1aabbc3e380178c2.png"/>

То есть. исходный вектор просто обрабатывается независимо по парам.

<h4>Фильтры</h4>

Итак, когда мы знаем, как выполнять преобразование Хаара, попробуем
разобраться с тем, что же оно нам даёт.

Полученные «полусуммы» (из-за того, что делим не на 2, приходится
использовать кавычки) — это, как мы уже выяснили, средние значения в
парах пикселей. То есть, фактически, значения полусумм — это
уменьшенная копия исходного изображения! Уменьшенная потому, что
полусумм в два раза меньше, чем исходных пикселей.

Но что такое разности?

Полусуммы усредняют значения яркостей, то есть «отфильтровывают»
случайные всплески значений. Можно считать, что это некоторый
частотный фильтр.

Аналогично, разности «выделяют» среди значений межпиксельные
«всплески» и устраняют константную составляющую. То есть, они
«отфильтровывают» низкие частоты.

Таким образом, преобразование Хаара — это пара фильтров, разделяющих
сигнал на низкочастотную и высокочастотную составляющие. Чтобы
получить исходный сигнал, нужно просто снова объединить эти
составляющие.

Что нам это даёт? Пусть у нас есть фотография-портрет. Низкочастотная
составляющая несёт в себе информацию об общей форме лица, о плавных
перепадах яркости. Высокочастотная — это шум и мелкие детали.

Обычно, когда мы смотрим на портрет, нас больше интересует
низкочастотная составляющая, а значит при сжатии часть высокочастотных
данных можно отбросить. Тем более, что, как мы выяснили, она обычно
имеет меньшие значения, а значит более компактно кодируется.

Степень сжатия можно увеличить, применяя преобразование Хаара
многократно. В самом деле, высокочастотная составляющая — это всего
лишь половина от всего набора чисел. Но что мешает применить нашу
процедуру ещё раз к низкочастотным данным? После повторного
применения, высокачастотная информация будет занимать уже 75%.

Хоть мы пока и говорили об одномерных цепочках чисел, этот подход
хорошо применим и для двумерных данных. Чтобы выполнить двумерное
преобразование Хаара (или аналогичное ему), нужно лишь выполнить его
для каждой строки и для каждого столбца.

После многократного применения к, например, фотографии замка
Лихтенштейн, получим следующий рисунок.

<img src="https://habrastorage.org/storage2/021/12e/919/02112e9190211983d73dd09ac6135aa3.png"/>

Черные области соответствуют низкой яркости, то есть значениям,
близким к нулю. Как показывает практика, если значение достаточно
мало, то его можно округлить или вообще обнулить без особого ущерба
для декодированного рисунка.

Этот процесс называется квантованием. И именно на этом этапе
происходит потеря части информации. (К слову, такой же подход
используется в JPEG, только там вместо преобразования Хаара
используется дискретное косинус-преобразование.) Меняя число
обнуляемых коэффициентов, можно регулировать степень сжатия!

Конечно, если обнулить слишком много, то искажения станут видны на
глаз. Во всём нужна мера!

После всех этих действий у нас останется матрица, содержащая много
нулей. Её можно записать построчно в файл и сжать каким-то
архиватором. Например, тем же 7Z. Результат будет неплох.

Декодирование производится в обратном порядке: распаковывем архив,
применяем обратное преобразование Хаара и записываем декодированную
картинку в файл. Вуаля!

<h4>Где эффективно преобразование Хаара?</h4>

Когда преобразование Хаара будет давать наилучший результат? Очевидно,
когда мы получим много нулей, то есть, когда изображение содержит
длинные участки одинаковых значений яркости. Тогда все разности
обнулятся. Это может быть, например, рентгеновский снимок,
отсканированный документ.

Говорят, что преобразование Хаара устраняет константную составляющую
(она же — момент нулевого порядка), то есть переводит константы в
нули.

Но всё же в реальных фотографиях областей с одинаковой яркостью не так
много. Попробуем усоврешенствовать преобразование, чтобы оно обнуляло
ещё и линейную составляющую. Иными словами, если значения яркости
будут увеличивать линейно, то они тоже обнулятся.

Эту задачу и более сложные (устранение моментов более высоких
порядков) решила Ингрид Добеши — один из создателей теории вейвлетов.

<h4>Преобразование Добеши</h4>

Для нашего усовершенствованного преобразования уже будет мало двух
точек. Поэтому будем брать по четыре значения, смещаясь каждый раз на
два.

То есть, если исходная последовательность — 1, 2, 3, 4, 5, 6,… , N-1,
N, то будем брать четвёрки (1, 2, 3, 4), (3, 4, 5, 6) и
т. д. Последняя четвёрка «кусает последовательность за хвост»: (N-1,
N, 1, 2).

Точно так же попробуем построить два фильтра: высокочастотный и
низкочастотный. Каждую четвёрку будем заменять на два числа. Так как
четвёрки перекрываются, то количество значений после преобразования не
изменится.

Для того, чтобы было удобно считать обратную матрицу потребуем также
ортогональности преобразования. Тогда поиск обратной матрицы сведётся
к транспонированию

Пусть значения яркостей в четвёрке равны x, y, z, t. Тогда первый фильтр запишем в виде

<img src="https://habrastorage.org/storage2/234/86f/ff2/23486fff2b0e3c009671073e7d83d770.png"/>

Четыре коэффициента, образующих вектор-строку матрицы преобразования, пока нам неизвестны.

Чтобы вектор-строка коэффициентов второго фильтра был ортогонален первому, возьмём те же коэффициенты но переставим их и поменяем знаки:

<img src="https://habrastorage.org/storage2/912/c56/4df/912c564dfcfc2774a537338ca8a99a6c.png"/>

Матрица преобразования будет иметь вид.

<img src="https://habrastorage.org/files/ef3/712/239/ef37122397f64f6c9473d026e3ee8382.png"/>

Требование ортогональности выполняется для первой и второй строк автоматически. Потребуем, чтобы строки 1 и 3 тоже были ортогональны:

<img src="https://habrastorage.org/storage2/dec/49c/0c7/dec49c0c7db1844ea1c86387692937b0.png"/>

Векторы должны иметь единичную длину (иначе определитель будет не единичным):

<img src="https://habrastorage.org/storage2/1c7/eb5/c04/1c7eb5c04c25eddcbb6a0b0a553d22b7.png"/>

Преобразование должно обнулять цепочку одинаковых значений (например, (1, 1, 1, 1)):

<img src="https://habrastorage.org/storage2/eba/c60/ab8/ebac60ab84de7f47f9419c7a093e2c52.png"/>

Преобразование должно обнулять цепочку линейно растущих значений (например, (1, 2, 3, 4)):

<img src="https://habrastorage.org/storage2/483/773/83e/48377383ece7e8e838b859071454b4a1.png"/>

Кстати, если обнуляется эта четвёрка, то будут обнуляться и любые другие линейно растущие или линейно убывающие. В этом легко убедиться, записав соответствующее уравнение и разделив все коэффициенты на первый множитель.

Получили 4 уравнения, связывающие коэффициенты. Решая их, получаем:

<img src="https://habrastorage.org/storage2/f95/d2f/268/f95d2f268e21fe5447eedeb2de321ae8.png"/>

Подставив их в матрицу, получаем искомое преобразования. После его применения к фотографиям получим больше нулей и малых коэффициентов, что позволит сжать изображение сильнее.

Другая приятная особенность — артефакты после квантования будут не так заметны.

Это преобразование получило название вейвлета D4 (читателю предлагается самостоятельно разгадать тайну этого буквенно-цифрового названия).

<h4>Другие вейвлеты</h4>

Мы, конечно, можем не остановиться на этом, и потребовать устранения параболической составляющей (момент 2-го порядка) и так далее. В результате получим вейвлеты D6, D8 и другие.

Чтобы не считать всё вручную, коэффициенты можно посмотреть в <a href="http://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B9%D0%B2%D0%BB%D0%B5%D1%82%D1%8B_%D0%94%D0%BE%D0%B1%D0%B5%D1%88%D0%B8">википедии</a>.

Добеши открыла весьма интересный способ получения коэффициентов этих преобразований, но увы, это уже выходит за рамки нашей статьи.

<h4>Домашнее задание</h4>

Чтобы окончательно разобраться с основами, предлагаю написать на вашем любимом языке программу, которая открывает изображение, выполняет преобразование Хаара (или даже D4), квантует результат, а потом сохраняет результат в файл. Попробуйте сжать этот файл своим любимым архиватором. Хорошо сжимается?

Попробуйте выполнить обратное преобразование. Как вы объясните характер артефактов на изображении?

<h4>Заключение</h4>
Итак, мы кратко рассмотрели основные идеи дискретного вейвлет-преобразования.

Конечно, в этой статье не были рассмотрены очень многие интересные математические детали и практические применения вейвлет-преобразований. Но нельзя объять необъятное. Да и многое сложно объяснить не повышая градус матана. Надеюсь, что и написанное оказалось кому-то полезным.

Спасибо за внимание!

Продолжение: <a href="http://habrahabr.ru/post/169615/">Вейвлет-сжатие «на пальцах»: практика</a>.

<h4>Литература</h4>
Есть много довольно неплохих книжек, которые дают более глубокое представление о вейвлетах. Начать рекомендую со следующих:
<ol>
	<li>Уэлстид С. Фракталы и вейвлеты для сжатия изображений в действии. — М.: Триумф, 2003.</li>
	<li>Штарк Г.-Г. Применение вейвлетов для ЦОС. — М.: Техносфера, 2007.</li>
</ol>