---
layout: post
title: Генерация LaTeX из Python
---

Для языка разметки LaTeX есть замечательный пакет clrs3, позволяющий описывать алгоритмы. Он используется для оформления псевдокода из книги Кормена, Лейзерсона, Ривеста и Штайна «Алгоритмы: построение и анализ» (отсюда и название пакета — первые буквы фамилий авторов). Оформление получается красивым, но вот писать команды LaTeX не так удобно, они здесь многословные. Потому мне и пришла в голову мысль попробовать написать простой конвертер из Python (который и сам похож на псевдокод) в LaTeX. Попробуем сделать такой.

Сразу хочу оговориться, что написание подобного конвертера, который учитывал бы все нюансы и особенности как Python, так и псевдокода из книги — непростая задача. Но попробуем сделать хотя бы простое преобразование. А дальше, когда разберёмся, можно будет наращивать функционал.

## Синтаксический анализ

Чтобы преобразовать код с одного языка на другой, необходимо разобраться в структуре кода. Такой анализ структуры называется синтаксическим анализом.

Так, например, человеку, который знает Python, ясно, что выражение `x + y * z` — это сумма `x` и произведения `y * z`. Но для компьютера это просто строка из пяти символов (не считая пробелы). Задача синтаксического анализа найти эти самые сумму и произведение. Причём для этого не обязательно знать, как их вычислять, и что это вообще такое. Такая задача — это уже семантический анализ.

Для компьютерных языков практически всегда известны синтаксические правила, по которым записываются команды. Они обычно достаточно просты, однозначны и их не очень много. Есть даже специальная нотация для записи таких правил — так называемая форма Бэкуса — Наура. И, конечно, есть алгоритмы — порой весьма изощрённые — которые по описанию синтаксиса и исходному тексту восстанавливают структуру.

Но мы не будем сами реализовывать эти алгоритмы. В самом деле, зачем? Ведь интерпретатор Python и так уже выполняет анализ. Просто воспользуемся его встроенным синтаксическим анализатором. Благо, для того, чтобы это сделать достаточно модуля `ast` из стандартной библиотеки.

Название модуля расшифровывается как abstract syntax tree, то есть абстрактное синтаксическое дерево. Дерево — потому что структуру очень удобно представлять в древовидной форме.

Например, выражению `x + y * z` будет соответствовать дерево

<div class="mermaid">
graph TD
+ --> x
+ --> *
* --> y
* --> z
</div>

В этом дереве чётко видна иерархия и сразу понятно, какая операция выполняется первой, а какая второй.

Именно так, а не

<div class="mermaid">
graph TD
* --> +
* --> z
+ --> x
+ --> y
</div>

Это дерево соответствует выражению `(x+y) * z`.

Когда есть дерево и видна структура, с ним можно выполнять различные манипуляции и генерировать на его основе код на другом языке, цепочки машинных команд и даже текстовые описания.

Чтобы сгенерировать описание для выражения, надо просто «прочитать» его дерево сверху вниз и слева направо. И тогда `x + y * z` превратится в «сумма `x` и произведения `y` и `z`», а `(x + y) * z` — в «произведение суммы `x` и `y` и `z`».

Заметим между делом, что такие «прочтения» формул можно записать в виде `+ x * y z` и `* + x y z`. А это ни что иное, как префиксная нотация для арифметических выражений — форма записи, прикоторой операция записывается перед операндами. Она, как и постфиксная (в которой операция записывается после операндов) не требует скобок для группировки действий. Этот пример хорошо иллюстрирует удобство древовидной структуры как промежуточного представления.

Так как префиксная форма — это лишь «прочтение» дерева, то можно для удобства записи использовать именно её. Рисовать дерево, особенно большое не всегда удобно. И чтобы было более привычно можно для записи использовать функции, ведь функции как раз и записываются перед операндами.

Тогда `x + y * z` естественным образом превращается в

```
Add(x, Mul(y, z))
```

`Add` — сложение (addition), `Mul` — умножение (multiplication).

На эту запись можно взглянуть и иначе: у нас есть два объекта: экземпляры классов `Add` и `Mul`. В каждом по две ссылки  — на левый и правый аргумент.

Мы уже вплотную подобрались к представлению, которое используется в модуле `ast` в Python.

## Модуль `ast`

Как я уже говорил, `ast` — это синтаксический анализатор, принимающий на вход строку с исходным текстом и возвращающим дерево в виде объектов с атрибутами и ссылками.
