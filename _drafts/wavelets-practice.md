---
layout: post
title:  "Вейвлет-сжатие «на пальцах»: практика"
---

16.02.2013

<img src="https://habrastorage.org/storage2/660/a28/594/660a28594694b01ac317e1ceea498ce4.png" align="left"/>
В <a href="http://habrahabr.ru/post/168517/">предыдущем посте</a> мы рассмотрели теоретические основы сжатия изображений с помощью дискретного вейвлет-преобразования. И хоть многие важные вопросы не были затронуты, полученных результатов достаточно, чтобы попробовать что-то сделать на практике.

К чему слова? Давайте напишем программу, сжимающую изображения! (Под катом много картинок!)

<habracut />

<h4>Инструментарий</h4>
Писать мы будем на языке программирования Python. Да, я знаю, что очень многие хотели бы, чтобы я иллюстрировал изложение кодом на <i>[впишите любимый язык программирования]</i>. Но Python представляется мне оптимальным выбором из-за своей чрезвычайной простоты (это, фактически, интерпретируемый псевдокод).

Нам потребуется интерпретатор и библиотека PIL (Python Imaging Library). В сети достаточно инструкций по их установке, поэтому не буду на этом останавливаться.

Единственное, хочу порекомендовать для разработки использовать ipython notebook. Замечательная штука, предоставляющая веб-интерфейс, напоминающий пакет Mathematica, но программируемая на Python.

<h4>Краткое содержание предыдущей серии</h4>

Итак, мы уже выяснили, что в реальных изображениях есть огромное количество избыточной информации. Избыточность эта связана с тем, что соседние значения яркости пикселей меняются достаточно плавно. Также мы узнали, что эту избыточность можно устранить при помощи обычных линейных преобразований, то есть умножений на матрицу.

Первое рассмотренное преобразование — преобразование Хаара — работает с парами значений яркости. Преобразование заключается в умножении на матрицу
<img src="https://habrastorage.org/storage2/f10/657/ddb/f10657ddb6497900c525b4d795bb8afc.png"/>

Второе преобразование — преобразование Добеши D4 — уже использует четвёрки значений, смещённые друг относительно друга на два значения. Поэтому матрица будет уже побольше (громоздкие коэффициенты обозначим через c<sub>i</sub>):
<img src="https://habrastorage.org/storage2/031/fce/db2/031fcedb29a53a3e7f0532a24eda21fd.png"/>

Коэффициенты преобразования мы находили решая систему нелинейных уравнений. Вторая строчка — это просто коэффициенты, записанные в обратном порядке с чередованием знаков.

Умножая эту матрицу на вектор-столбец из 4-х значений яркости, получаем только два значения (низкочастотный и высокочастотный коэффициенты). Именно из-за такой несправедливости четвёрки нужно брать не подряд, а «внахлёст», с шагом 2.

Например, если у нас есть значения [1, 2, 3, 4], то нужно взять две четвёрки: [1, 2, 3, 4] (сюрприз, сюрприз!) и [3, 4, 1, 2]. Последняя имеет такой странный вид из-за того, что нам не хватило значений справа и пришлось вернуться по кругу в начало.

К слову, матрица всего преобразования в этом случае будет иметь вид:
<img src="https://habrastorage.org/storage2/f1f/4ff/e3b/f1f4ffe3b109c2c729ebb4acb04bc49c.png"/>

Аналогично можно записать матрицы преобразований более высокого порядка: D6, D8 и так далее. (Номера всегда чётные. Подумайте, почему так.)

<h4>Начинаем!</h4>

Допустим, мы выбрали для программирования вейвлет-преобразование D4. Чтобы каждый раз не проводить вычисления, поместим коэффициенты в список.

<source lang="python">
from math import sqrt
CL = [(1 + sqrt(3)) / (4 * sqrt(2)),
    (3 + sqrt(3)) / (4 * sqrt(2)),
    (3 - sqrt(3)) / (4 * sqrt(2)),
    (1 - sqrt(3)) / (4 * sqrt(2))]
</source>

Буква L означает, что это коэффициенты первой строки, относящейся к фильтру низких (L, low) частот.

Это достаточно универсальный подход. Если мы захотим реализовать другое преобразование — просто заменим список.

Коэффициенты высокочастотного фильтра (HPF, high-pass filter) будем находить при помощи отдельной функции, записывающей список в обратном порядке и чередующей знаки.

<source lang="python">
def hpf_coeffs(CL):
    N = len(CL)                    # Количество коэффициентов
    CH = [(-1)**k * CL[N - k - 1]  # Коэффициенты в обратном порядке с чередованием знака
        for k in xrange(N)]
    return CH
</source>

Выражение в скобках, если кто не знает, — это генератор списка. Весьма удобная штука.

<h4>Прямое одномерное преобразование</h4>

Теперь, когда у нас есть коэффициенты, мы можем выполнить само преобразование. Его результатом будет список, содержащий взвешенные суммы с коэффициентами поочерёдно из списков CL и CH.

Взвешенные суммы (суммы попарных произведений) — это произведения строк матрицы на вектор-столбец. Чётные строки матрицы — это низкочастотый фильтр, а нечётные — высокочастотный. Вот откуда чередование.

Списки из взвешенных суммы, вычисляемых «вдоль» другого списка в математике называются свёртками. Есть эффективные алгоритмы вычисления этих свёрток на основе преобразования Фурье. (Внезапно, правда? Преобразование Фурье — это синусы и косинусы, и вдруг для суммирования используется!) Но мы сторонники простоты и не будем заниматься преждевременными оптимизациями. Посчитаем в лоб, так понятнее. А оптимизации и красивые хаки оставим читателю как упражнение.

Функцию назовём pconv. P — от слова pair (пара), а conv — convolution (свёртка).

<source lang="python">
def pconv(data, CL, CH, delta = 0):
    assert(len(CL) == len(CH))         # Размеры списков коэффициентов должны быть равны
    N = len(CL)
    M = len(data)
    out = []                           # Список с результатом, пока пустой
    for k in xrange(0, M, 2):  # Перебираем числа 0, 2, 4…
        sL = 0                         # Низкочастотный коэффициент
        sH = 0                         # Высокочастотный коэффициент
        for i in xrange(N):      # Находим сами взвешенные суммы
            sL += data[(k + i - delta) % M] * CL[i]
            sH += data[(k + i - delta) % M] * CH[i]
        out.append(sL)                 # Добавляем коэффициенты в список
        out.append(sH)
    return out
</source>

Может быть непонятно, что это за значение delta, равное по умолчанию нулю. Оно позволяет нам начать свёртку не с первого элемента, а с произвольного. Это пригодится нам чуть позже.

Вычисление остатка (выражение «%M») при вычислении взвешенных сумм нужно, чтобы не выходить за границы списка. Если M = 4, а индекс вдруг окажется, равным 5, то мы вернёмся снова к 1-му элементу, так как 5%4 даёт в результате 1.

Давайте, испытаем нашу функцию на ненормированном преобразовании Хаара (которое с полусуммами и полуразностями).

<source lang="python">
>>>C = [0.5, 0.5]
>>>pconv([1, 2, 3, 4], C, hpf_coeffs(C))
[1.5, -0.5, 3.5, -0.5]
</source>

Работает!

<h4>А обратно?</h4>

Как читатель помнит, мы специально так конструировали наши матрицы, чтобы обратное преобразование выполнялось как можно проще. Благодаря ортогональности матриц H и D4, обратные матрицы для них можно найти простым транспонированием.

Рассмотрим ещё раз матрицу преобразования D4, но для вектор-столбца произвольной длины:
<img src="https://habrastorage.org/storage2/2e1/4bc/c04/2e14bcc04bc6fe416c2154f05195a149.png"/>

Умножая такую матрицу на вектор-столбец со значениями яркостей пикселей мы получим декоррелированные значения. Правда, матрица очень большая, поэтому вместо явного умножения мы воспользовались свёрткой.

Обратную матрицу можно получить транспонированием:
<img src="https://habrastorage.org/storage2/0a2/515/543/0a2515543dca5c97b5dc08447c87e732.png"/>

Очень похоже на исходную матрицу, но нет квадратного куска в нижнем левом углу. Хотя если «отрезать» последние два столбца и «приклеить» в начало, то получится матрица такой же формы (хоть и с другими коэффициентами) и мы сможем воспользоваться уже готовой функцией pconv. Стоп! А ведь у нас там есть параметр delta, который задаёт смещение в исходных данных. А ведь это и есть то самое отрезание и приклеивание. Тайна параметра delta раскрыта!

Для D4 нужно «отрезать» 2 последних столбца, для D6 — четыре и т. д.

Дело за малым — определить, порядок коэффициентов в строках обратной матрицы. Для D4 порядок очевиден:
<img src="https://habrastorage.org/storage2/a0b/b5a/7f8/a0bb5a7f8d159e3fcf207105d030c607.png"/>

Но как быть в случае D6, D8 и других? Посмотрим на матрицу преобразования D4. Нас интересуют строки транспонированной матрицы, то есть столбцы исходной.

Наши векторы — это третий и четвёртый столбики. Независимо от порядка преобразования смещение строк всегда происходит на два элемента, поэтому закономерность тут такая.

Первый вектор:
[предпоследний элемент первой строки, предпоследний элемент второй, первый элемент первой строки (она совпадает с третьей), первый элемент второй].

Второй вектор:
[последний элемент первой строки, последний элемент второй, второй элемент первой строки (она совпадает с третьей), второй элемент второй].

То есть, коэффициенты поочерёдно выбираются с шагом 2 из CL и CH начиная с предпоследнего для первой строки обратной матрицы или последнего для второй строки.

Это правило будет верно и для D4, и для D6 и даже для преобразования Хаара (которое на самом деле то же, что и D2).

В Python к предпоследнему элементу можно обратиться по индексу -2, а к последнему по индексу -1. Эту полезную особенность мы и использовали в pconv.

Напишем функцию для получения списка коэффициентов обратной матрицы, работающую по описанному алгоритму.
<source lang="python">
def icoeffs(CL, CH):
    assert(len(CL) == len(CH))         # Размеры списков коэффициентов должны быть равны
    iCL = []  # Коэффициенты первой строки
    iCH = []  # Коэффициенты второй строки
    for k in xrange(0, len(CL), 2):
        iCL.extend([CL[k-2], CH[k-2]])
        iCH.extend([CL[k-1], CH[k-1]])
    return (iCL, iCH)
</source>

Проверим её работу:
<source lang="python">
>>>C = [0, 1, 2, 3]
>>>icoeffs(C, hpf_coeffs(C))
([2, 1, 0, 3], [3, 0, 1, -2])
</source>

Похоже, что коэффициенты переупорядочиваются правильно.

Можно протестировать работу функций, преобразовав какой-то список (скажем, [0, 1, 2, 3]), а потом выполнив обратное преобразование.
<source lang="python">
>>>CL = [(1 + sqrt(3)) / (4 * sqrt(2)),
>>>    (3 + sqrt(3)) / (4 * sqrt(2)),
>>>    (3 - sqrt(3)) / (4 * sqrt(2)),
>>>    (1 - sqrt(3)) / (4 * sqrt(2))]
>>>X = [0, 1, 2, 3]
>>>CH = hpf_coeffs(CL)
>>>iCL, iCH = icoeffs(CL, CH)
>>>Y = pconv(X, CL, CH)
>>>X2 = pconv(Y, iCL, iCH, len(CL) - 2)
[2.5077929123346285e-16, 1.0, 1.9999999999999991, 2.9999999999999991]
</source>

Что за ерунда! Должно было получиться снова [0, 1, 2, 3]! Стоп, ложная тревога. Первое число — это всего-навсего <img src="https://habrastorage.org/storage2/cdc/8ff/973/cdc8ff97322810897566dbfa56f75124.png"/>, то есть практически ноль. Остальные числа тоже близки к исходным. Дело в том, что мы работаем с иррациональными числами, а в таких делах неизбежны ошибки округления.

<h4>Двумерное преобразование</h4>

Так, преобразования мы запрограммировали. Но преобразования-то эти одномерные! А картинки, которые мы планируем сжимать, очень даже двумерны. Но это легко решается. Двумерное вейвлет-преобразование выполняется как одномерное по всем строчкам, а потом по всем столбикам (или наоборот, по вкусу).

Работать с изображениями мы будем при помощи библиотеки PIL, основанной на numpy. А там есть удобный способ для обращения к элементам двумерных массивов.

Если значения яркостей пикселей нашего изображения хранятся в переменной image, то получить список яркостей 4-й, например, строки, можно так:
<source lang="python">
image[4, :]
</source>

А список яркостей в 3-м столбце так:
<source lang="python">
image[:, 3]
</source>

Возьмём для экспериментов какое-то изображение. Важно, чтобы его размеры были степенями двойки! (Вообще, важно, чтобы они были чётными, но мы потом будем делать повторные преобразования.)

Например, можно взять такое (раз уж Лена всем поднадоела):
<img src="https://habrastorage.org/storage2/328/5b4/a25/3285b4a2561416779c3cdd7e4e380cab.png"/>

У него размеры 512×512, так что оно нам подходит.

Загрузим его в память (заодно преобразовав к чёрно-белому виду и сформировав матрицу яркостей):
<source lang="python">
import PIL.Image as Image
image = Image.open('/tmp/boat.png').convert('L')
image = array(image) / 255.0 # Диапазон яркостей — [0, 1]
imshow(image, cmap=cm.gray)  # Отобразим на экране
</source>

На экране должно появиться что-то вроде:
<img src="https://habrastorage.org/storage2/40b/71e/4c5/40b71e4c5fbe942593a23a5b5a705fa4.png"/>

Итак, переменная image — это массив яркостей.

Напишем функцию для двумерного вейвлет-преобразования. Так как чередующиеся низко- и высокочастотные коэффициенты выглядят некрасиво, переупорядочим их. Низкочастотные — влево и вверх, высокочастотные — вправо и вниз.

Так как преобразования выполняются и по строкам, и по столбца, то низкочастотные коэффициенты, которые составляют уменьшенную копию исходной картинки, сгруппируются в верхнем левом углу.

<source lang="python">
def dwt2(image, CL):
    CH = hpf_coeffs(CL)   # Вычисляем недостающие коэффициенты
    w, h = image.shape    # Размеры изображения
    imageT = image.copy() # Копируем исходное изображение для преобразования
    for i in xrange(h):   # Обрабатываем строки
        imageT[i, :] = pconv(imageT[i, :], CL, CH)
    for i in xrange(w):   # Обрабатываем столбцы
        imageT[:, i] = pconv(imageT[:, i], CL, CH)

    # Переупорядочиваем столбцы и строки
    data = imageT.copy()
    data[0:h/2, 0:w/2] = imageT[0:h:2, 0:w:2]
    data[h/2:h, 0:w/2] = imageT[1:h:2, 0:w:2]
    data[0:h/2, w/2:w] = imageT[0:h:2, 1:w:2]
    data[h/2:h, w/2:w] = imageT[1:h:2, 1:w:2]
    return data
</source>

Проверим работу нашей функции на преобразовании D4, коэффициенты которого мы поместили в CL и CH.
<source lang="python">
data2 = dwt2(image, CL)
imshow(data2, cmap=cm.gray)
</source>

Сразу предупреждаю! Так как мы ничего не оптимизировали, то работать будет медленно. На моём скромном нетбуке расчёт занял полтора десятка секунд.

В итоге должно получиться такая картинка.
<img src="https://habrastorage.org/storage2/660/a28/594/660a28594694b01ac317e1ceea498ce4.png"/>

Всё, как мы и предполагали! Уменьшенное изображение в углу и небольшие по модулю (о чём говорит чёрный цвет) коэффициенты в остальной части.

А вот график значений вдоль 50-й строки преобразованного изображения.
<img src="https://habrastorage.org/storage2/3cc/59b/1d7/3cc59b1d7c0bf57150839450b1e58638.png"/>

Видно, что в первой половине, соответствующей уменьшенной копии, диапазон изменения высокий, в то время как высокочастотные коэффициенты близки к нулю.

Можно попробовать с вейвлетом Хаара:
<source lang="python">
C = [1/sqrt(2), 1/sqrt(2)]
data3 = dwt2(image, C)
imshow(data3, cmap=cm.gray)
</source>

<img src="https://habrastorage.org/storage2/660/a28/594/660a28594694b01ac317e1ceea498ce4.png"/>

При наличии хорошего зрения и монитора можно заметить, что в высокочастотной части проступает больше деталей. Оно и понятно — ведь тут фильтровалась лишь линейная составляющая, а в D4 — ещё и квадратическая.

Или даже взять коэффициенты для D6 из <a href="http://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B9%D0%B2%D0%BB%D0%B5%D1%82%D1%8B_%D0%94%D0%BE%D0%B1%D0%B5%D1%88%D0%B8">википедии</a> (не забудьте разделить их на <img src="https://habrastorage.org/storage2/f76/6f9/eec/f766f9eec1869f743a665d5e2cdf835d.png"/> они там нормированы на двойку). А самые смелые могут вообще получить коэффициенты аналитически.

Чем больше порядок преобразования, тем темнее будут области с высокочастотными коэффициентами.

<h4>Обратное двумерное преобразование</h4>

То, что мы умеем делать двумерное преобразование — это здорово, но это умение бесполезно без обратного преобразования.

Его как раз сделать несложно. Выполняем те же шаги, что и с прямым преобразованием, но в обратном порядке. И не забываем, про другие коэффициенты и ненулевое значение delta в pconv.

<source lang="python">
def idwt2(data, CL):
    w, h = data.shape   # Размеры изображения
    
    # Переупорядочиваем столбцы и строки обратно
    imageT = data.copy()
    imageT[0:h:2, 0:w:2] = data[0:h/2, 0:w/2]
    imageT[1:h:2, 0:w:2] = data[h/2:h, 0:w/2]
    imageT[0:h:2, 1:w:2] = data[0:h/2, w/2:w]
    imageT[1:h:2, 1:w:2] = data[h/2:h, w/2:w]

    CH = hpf_coeffs(CL)
    iCL, iCH = icoeffs(CL, CH)
    image = imageT.copy() # Копируем исходное изображение для преобразования
    for i in xrange(w):   # Обрабатывем столбцы
        image[:, i] = pconv(image[:, i], iCL, iCH, delta=len(iCL)-2)
    for i in xrange(h):   # Обрабатывем строки
        image[i, :] = pconv(image[i, :], iCL, iCH, delta=len(iCL)-2)

    return image
</source>

Для проверки выполним обратное преобразование полученного ранее изображения image2.
<source lang="python">
>>>image_rec = idwt2(image2, CL)
>>>imshow(image_rec, cmap=cm.gray)
</source>

<img src="https://habrastorage.org/storage2/40b/71e/4c5/40b71e4c5fbe942593a23a5b5a705fa4.png"/>

Получили исходное изображение (ну, или очень-очень похожее), так что у нас всё работает!

<h4>Не останавливаемся на достигнутом!</h4>

Хорошо, мы получили много близких к нулю коэффициентов. Но у нас всё равно четверть картинки занимают низкочастотные данные. А что если и их преобразовать? Это можно сделать в цикле, преобразовывая верхний левый угол, пока не он станет слишком мал.

Для вейвлета D4 предельным размером «уголка» являются размеры 4×4, так как изображение меньшего размера преобразовать уже не удастся — не хватит значений, чтобы умножить на 4 коэффициента матрицы.

Например, для преобразования D4, подобное рекурсивное преобразование можно запрограммировать следующим образом:
<source lang="python">
data = image.copy()
w, h = data.shape 
while w >= len(CL) && h >= len(CL):
    data[0:w, 0:h] = dwt2(data[0:w, 0:h], CL)
    w /= 2
    h /= 2
imshow(data, cmap=cm.gray)
</source>

Картинка при этом получается не особо интересная.
<img src="https://habrastorage.org/storage2/12d/e67/a4f/12de67a4f8e15f465fb30c6c9f527b28.png"/>

Посмотрим, в каком диапазоне меняются значения. Вот график значений из нулевой строки.
<img src="https://habrastorage.org/storage2/064/ea4/df7/064ea4df7f8d286fa8ed2343c0a4e216.png"/>

Первые несколько значений на самом деле зашкаливают. Зато остальные малы.

<h4>Удаляем лишнее</h4>

А теперь давайте проделаем то, ради чего, всё это задумывалось — получим много нулей!

Это можно делать разными способами. Например, можно округлять значения до необходимого количества значащих цифр (частный случай квантования). Но мы поступим проще — заменим коэффициенты, меньшие по модулю некоторого значения, на ноль.

В качестве такого порогового значения возьмём 0,05. Чем больше, тем больше нулей, но и тем больше потери!

<source lang="python">
from numpy import abs
threshold = 0.05
data[abs(data)<threshold] = 0
</source>

После этого график станет заметно ровнее.
<img src="http://habrastorage.org/storage2/d80/f20/fe6/d80f20fe6fd9654915911c910afaad78.png"/>

Подсчитаем количество нулей:
<source lang="python">
>>>sum(data == 0)
224000
</source>

Неплохо! Учитывая, что в изображении всего-то 512×512=262144 пикселя, выходит, что мы просто отбросили <b>85,4%</b> имеющихся коэффициентов!!!

Сильно ли это повредило изображению?

Выполним обратное преобразование. (Как именно — упражнение для читателя!)

На маленьком рисунке искажения увидеть вообще не удастся, поэтому приведу полноразмерные картинки — оригинал и реконструированное изображение.

<img src="http://habrastorage.org/storage2/ccd/a1d/80f/ccda1d80f02c0efeb31bff15e5ba99ec.png"/><img src="http://habrastorage.org/storage2/780/49e/aa0/78049eaa0f4f4550ce4b234909ad0c49.png"/>

Кто увидел отличия — тот молодец! Я вот с трудом нашёл.

А если взять 0,1 (обнуляется 92,9% коэффициентов)?
<img src="1450827299750550431942"/>
Тоже неплохо!

Возьмём теперь порог, равный 0,2 (96,9% отбрасываемых коэффициентов).
<img src="http://habrastorage.org/storage2/063/351/507/0633515071a88e1afd7b771ee6685a57.png"/>
Уже заметны серьёзные искажения.

Ну и наконец, попробуем отбросить всё, что меньше по модулю, чем 0,5 (99,2% отброшено).
<img src="http://habrastorage.org/storage2/f61/2e5/e1b/f612e5e1b97dc3431992f2a7ba65c57c.png"/>
Жуткое мыло! Но квадратики не такие контрастные, как в пережатых JPEG. Мы использовали D4, поэтому мыло «квадратичное», с плавными градиентами внутри.

Для сравнения попробуем с этим же порогом (то есть, 0,5) сжать изображение, но уже с использованием преобразования Хаара. 
<img src="http://habrastorage.org/storage2/446/5e5/32d/4465e532d60f8bec8764701491e22d79.png"/>

Ужас-ужас! Ещё и линейные искажения. И отброшено всего-то 99,2% коэффициентов. Хуже, чем D4.

<h4>Выводы</h4>
Итак.

1. После преобразования D4 мы можем смело отбросить 90% коэффициентов простым обнулением и не потеряем в качестве. А если применить продвинутые методики квантования, то результат можно ещё улучшить.

2. D4 лучше, чем D2 (преобразование Хаара). D6 будет лучше, чем D4 и так далее. Но тут есть проблема. Чем выше порядок, тем раньше нам придётся остановить процесс рекурсивного преобразования верхнего левого уголка. Так что во всём нужно знать меру.

<h4>Что дальше?</h4>
На самом деле мы ещё не закончили. Да, мы отбросили 90% коэффициентов. Но это вещественные коэффициенты, занимающие 8 байт! Так что сжатие у нас будет очень и очень небольшое. Поэтому при сохранении в файл коэффициенты округляют и используют для хранения ограниченное количество бит. Кроме того, для лучшей упаковки коэффициенты можно переупорядочить особым образом. Об этом можно написать не одну статью.

Но даже если просто сохранить массив с коэффициентами в виде чисел с плавающей точкой половинной точности (float16), то после сжатия архиватором xz получается файл размером 43604 байта.

Сохранение можно осуществить так.
<source lang="python">
from numpy import save
save("boat", data.astype(float16))
</source>

Несмотря на значительную потерю точности из-за преобразования float64→float16 и сжатие в лоб без каких-либо специальных алгоритмов, получаем довольно неплохой результат:
<img src="1450827299750550431942"/>

При этом получили фактор сжатия, равный (512×512)/43604 ≈ 6 или 1,33 бит/пиксель. Не бог весть что, но мы не сильно-то и старались сжать. Правильное квантование и хороший алгоритм сжатия могут очень существенно улучшить этот результат! Так что тут есть куда расти! Но это уже выходит за рамки нашего «проекта на вечер». Может, как-нибудь в другой раз. ;)

<h4>Домашнее задание</h4>
1. Попробуйте объединить приведённые куски кода в один скрипт. Пусть он принимает в качестве параметров имя графического файла, величину порога и тип преобразования, сжимает указанное изображения, и сохраняет результаты в файл. Предусмотрите два режима работы: сжатие и распаковка.
2. Поэкспериментируйте с кодированием и декодированием разных изображений.
3. Попробуйте другие перобразования.
4. Подумайте, как более экономно сжимать коэффициенты.
5. Попробуйте ускорить работу программы.
6. Реализуйте сжатие цветных изображений.
7. Снимите ограничение на размеры (пока что они должны быть степенями двойки).
8. ???
9. PROFIT!!!

Очередной убийца JPEG готов! ;)

Всем спасибо! Надеюсь, было интересно!