https://twitter.com/vlcdn/status/1352586620592074755
@dotofsp
 принёс сегодня вопрос про Python. Что выведет print({1: "a", True: "b", 1.0: "c"})?
Вопрос несложный. Правильный ответ тут {1: "c"}. Дело в том, что для всех трёх ключей хэши равны 1 и значения совпадают (True — это единичка).
Интереснее вопрос, как считаются хэши.

Для чисел используется редукция по модулю некоторого числа p. В исходниках оно задано как 2 ** _Py_HASH_BITS - 1. Значение _Py_HASH_BITS может быть 31 или 61 в зависимости от разрядности системы. В обоих случаях это числа Мерсенна, то есть простые. (А 2⁶³-1, кстати, нет.)

Редукция по модулю p для целых чисел — это остаток от деления на p. Эту операцию в Python расширяют и на рациональные числа.
При этом сохраняется свойство
r(a × b) = r(a) × r(b) mod p.
Это свойство полезно для вычисления хэшей больших чисел с плавающей точкой.

Если у числа с плавающей точкой большая экспонента, то мы можем посчитать хэш от мантиссы отдельно, а от множителя, задающего порядок, отдельно. Это можно сделать эффективно, так как этот множитель — степень двойки или десятки (для decimal).

Остаются ещё бесконечности и None, но для них можно предопределённую константу возвращать.
А для отрицательных — берём хэш от модуля и ставим минус перед результатом.

Есть интересный частный случай. Значение -1 в реализациях хэшей внутри Python зарезервировано для ошибок. Поэтому хэш от -1 приняли равным -2.

В итоге получается забавная ситуация:
…
hash(-3)=-3
hash(-2)=-2
hash(-1)=-2 <<<
hash(0)=0
hash(1)=1
…
Но теперь понятно, почему так.
Подробности можно посмотреть тут: https://github.com/python/cpython/blob/master/Python/pyhash.c

Кстати, а почему {1: "c"}, а не {1.0: "c"}?
А просто каждая следующая пара ключ-значение обновляла одну и ту же ячейку хеш-таблицы. А там уже ключ 1.

См. также https://habr.com/ru/post/579410/comments/#comment_23513486

Хэш от рационального числа a / b часто считают так:

hash(a / b) = hash(a * inv(b))

где inv — это обратный элемент по модулю. Если в качестве модуля берём простое число, там достаточно быстро считается и асимптотика зависит только от самого модуля, а это константа. Да, тяжелее умножения, но зато мы асимптотику улучшаем переходом на хэш-таблицу. Впрочем, для ограничений задачи на практике в этом большого смысла и нет, константа под асимптотикой съест всё преимущество, наверное.
Про float уже сказали, что можно заменить на умножения. Или наоборот. Несмотря на то, что я числам с плавающей точкой не доверяю, при ограничениях задачи, наверное, всё можно было бы на них сделать и работало бы.
Если вдруг хочется полностью от float избавиться, то можно и корень выкинуть. Можно счётчик сделать хитрее. Надо будет хранить пару: (число точек на прямой, число встреченных пар). Изначально там (1, 0). Каждый раз когда добавляем пару, увеличиваем второе число на 1. Если оно стало равно первому, то увеличиваем уже его, а счётчик пар сбрасываем в 0. На асимптотику не влияет, просто на каждой итерации добавляется проверка и иногда ещё одно сложение и присваиванием.

для 1/1 и 2/2 хэши будут одинаковыми.

inv(b) — это такое (уникальное) число, a inv(b) = 1 (mod m).

Из малой теоремы Ферма следует, что inv(b) = b^(phi(m) - 1) (mod m). То есть, переходим от инверсии к обычной степени, а там можно раскрыть скобки и перегруппировать множители. И получаем, что inv(k b) = inv(k) inv(b) (mod m).

Соответственно, для несокращённой дроби ka / kb получаем k a inv(k b) = (k inv(k)) (a inv(b)) = a inv(b) (mod m), а это то же, что и для дроби a / b.

То есть, можно не сокращать.

Кстати, в Python легко обратный элемент считать, там это функция pow умеет:

pow(b, -1, m)  # inv(b)

Так что можно убедиться:

>>> a, b, m = 15, 33, 17389
>>> inv = lambda x: pow(x, -1, m)
>>> (a * inv(b)) % m
12647
>>> k = 30
>>> (k * a * inv(k * b)) % m
12647

Но и на C++ это легко реализуется через быстрое возведение в степень.

Правда, надо сделать замечание, что числа должны быть взаимно простыми с m. Но можно взять простое m, большее, чем верхняя граница из условия задачи, тогда и GCD считать не нужно.


masai
24.09.2021 в 11:51

На самом деле можно даже брать m, не большее, чем граница, а большее, чем корень из границы. Этого достаточно, чтоб m не был множителем чисел из указанного диапазона. Если в задаче до 10^4 числа, то можно взять какое-то простое, большее 100. Это произвольные числа, так что можно вообще выбрать то, которое удобнее.

Если взять m=131, то возводить надо в степень 129 = 2^7 + 1. Тогда получается такой код:

>>> def inv(a):
...     r = a
...     for _ in range(7):
...         r = (r * r) % 131
...     return (r * a) % 131
...
>>> inv(1234)
81
>>> pow(1234, -1, 131)
81

А, не. Про корень я наврал, конечно. :) Так как само число m уже имеет множитель m.

Ну, тогда можно взять m = 2 ^ 15 + 3 = 32771 (это простое число) и в алгоритме выше заменить 7 итераций на 15 и 131 на 32771.

