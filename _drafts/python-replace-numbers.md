https://twitter.com/vlcdn/status/1348777301274714113

7. Многие знают, что числа от -5 до 255 интернированы. То есть заранее размещены в памяти.
В эту память при желании можно залезть и поменять значение так, чтоб литерал 5 имел значение 7. Весёлой отладки!

Я смотрю, многим понравился этот твит. Вот в качестве бонуса код, который заменяет 4 на 5.
>>> import ctypes
>>> ctypes.memmove(id(4) + 24, id(5) + 24, 8)
>>> print(2 * 2)
5

> вот только повторный запуск подвисает вычисления любые(

Числа активно используются в стандартной библиотеке и внутри самого интерпретатора. Потому и подвисает, что какой-то алгоритм неправильно начинает работать.
Ну и если ломаешь интерпретатор, то не стоит удивляться тому, что он сломался. :)

Да ничего особо загадочного нет. :)
id возвращает, фактически, адрес в памяти, где лежит структура, представляющая объект. 24 — смещение в этой структуре. 8 — сколько байт скопировать из одной в другой.

В исходниках CPuthon можно подсмотреть структуру объекта для целых чисел. Это файл https://github.com/python/cpython/tree/master/Include/longintrepr.h (см. struct _longobject).
Этот объект переменной длины, поэтому там вначале заголовок PyObject_VAR_HEAD.
Если походить по файлам, то можно восстановить всю структуру.

id ссылается на 8-байтовое целое со счётчиком ссылок. Там скорее всего достаточно большое число, так как числа 4 и 5 популярны.
id+8 — адрес объекта-метатипа.
id+16 — количество цифр (тоже 8-байтовое) в системе с основанием 2³⁰.
id+24 — массив цифр.

Сами цифры — это 4-байтовые целые (в них как раз помещается 30 бит). Так что я погорячился, можно было копировать и 4 байта. Это тоже сработало бы.

Смотреть, что за значения по указанному адресу можно тоже с помощью ctypes.
Например, вытащим счётчик ссылок.

https://pbs.twimg.com/media/ErjoDvUXAAoNeVX?format=jpg&name=900x900

