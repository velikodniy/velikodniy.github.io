https://twitter.com/vlcdn/status/1328427520300101637

Кстати, ещё одна штука, которую, похоже, не так часто используют — это CORAL. Это функция потерь для упорядоченных классов. Например, для классификации возрастных групп (для которых, кстати, CORAL — SotA для пары датасетов по версии PapersWithCode).

Зачем вообще нужен новый лосс? А просто в этой задаче у нас не совсем регрессия (у нас же не точный возраст, а группы) и не совсем классификация (классы упорядочены, хочется это использовать).

Идея там очень простая. Пусть у нас есть N классов. Мы просим классификатор выдавать единственное действительное число и прибавляем его к N-1 обучаемому порогу. И считаем, сколько элементов больше нуля — это и будет номер класса. Все меньше — нулевой класс, все больше — (N-1)-й.

Метки мы формируем соответственно. Для нулевого класса метка будет (N-1)-вектором из нулей. Для первого — первый элемент единичка, для второго — первые два. И так далее. Похоже на прогресс-бар. :)

Очевидно, у обученной модели в таком сеттинге пороги получатся возрастающими.
На выходы и подобные метки цепляем кроссэнтропию. И выход (который просто число) классификатора будет тем больше, чем больше номер класса.

И всё это работает просто замечательно, когда есть какие-то упорядоченные классы.
Полезная фишка — можно потом пороги выбросить и использовать выход классификатора (при некоторой доле везения и после калибровки) для оценки точного значения до разбиения на классы.

